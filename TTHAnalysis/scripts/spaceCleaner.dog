#!/bin/bash
#set -x

## help
function _help() {
    printf "Usage $(basename $0) <chunks-path> <eos-path> <dog-freq>\n\n"; exit 0;
}
for arg in ${@}; do
    { [ "$arg" == "--help" ] || [ "$arg" == "-h" ] || [ "$arg" == "-help" ]; } && _help
done

## env variables & internal configurables
[ -z "$CMSSW_BASE" ] && { echo "do cmsenv"; exit 1; }
input=$1
output=$2
dogfreq=$3
quotaThreshold=50
haddMode="nano" ## either 'nano' or 'normal'
finishedBefore=0
mkdir $output/trees -p
fileChecker=$CMSSW_BASE/src/CMGTools/TTHAnalysis/scripts/checkFiles.py
logFile=spaceCleaner_dog.log
{ [ -z $input ] || [ -z $output ]; } && _help

## signal handler
trap prompt SIGINT ## ctrl+c
function prompt() {
    printf "\nOptions accessible via this prompt: --dogfreq <freq>, --quota-threshold <threshold>, quota, exit
input > " > /dev/stderr
    read -a args
    for (( i=0; i<${#args[*]}; i++ )); do
	[ "${args[$i]}" == "--dogfreq" ] && { dogfreq=${args[$i+1]}; echo "new dogfreq=$dogfreq" > /dev/stderr; continue 2; }
	[ "${args[$i]}" == "--quota-threshold" ] && { quotaThreshold=${args[$i+1]}; echo "new quotaThreshold=$quotaThreshold" > /dev/stderr; continue 2; }
	[ "${args[$i]}" == "quota" ] && { fs quota > /dev/stderr; continue; }
	[ "${args[$i]}" == "exit" ] && exit 0
    done
    args=""
    return
}

## ~~~~~ DEPRICATED ~~~~~
## this tool returns if finds that more jobs have finished than its previous check
## help: checkIfJobsFinished <dogfreq>
# function checkIfJobsFinished() {
#     while true; do
# 	finishedJobs=$(condor_q | grep $USER | awk 'BEGIN{sum=0};{sum+=$6};END{print sum}')
# 	(( $finishedJobs < $finishedBefore )) && return 0
# 	finishedBefore=$finishedJobs
# 	sleep $1
#     done
# }

## this tools checks in the log files of the chunks and if they're done it copies them to eos (each process in seperate dir)
## help: moveFinishedToEOS <chunksPath> <eosPath>
function moveFinishedToEOS() {
    chunksPath=$1
    eosPath=$2
    for chunkPath in $(ls $chunksPath/*_Chunk* -d); do
	grep 'return value 0' $chunkPath/*log > /dev/null && {
	    echo "Finished chunk found. $chunkPath" | tee $logFile
	    proc=$(echo $chunkPath | sed -r "s@.*/([^/]*)_Chunk[0-9]*@\1@")
	    [ ! -d $eosPath/$proc ] && mkdir $eosPath/$proc
	    mv $chunkPath $eosPath/$proc/.
	}
    done
    return 0
}

## this tool checks the remote files associated to a task given and if are not corrupted it hadds them
## help: checkAndHadd <remotePath> <taskName> 
function checkAndHadd() {
    remotePath=$1
    taskName=$2
    sourceFiles=$remotePath/$taskName/*_Chunk*/*.root
    rm -f taskfiles.log
    python $fileChecker --log taskfiles.log $files
    # if the file with the corrupted files list is empty
    if ! [ -s taskfiles.log ]; then
	hadd -ff $remotePath/trees/$taskName.root $sourceFiles || return 1
    else
	echo "Task $taskName failed to hadd" | tee $logFile
    fi
    return 0
}

## this tool checks the remote files associated to a task given and if are not corrupted it hadds them (using haddChunks.py -n)
## help: checkAndHaddNanos <remotePath> <taskName> 
function checkAndHaddNanos() {
    _remotePath=$1
    _taskName=$2
    _sourceFiles=$_remotePath/$_taskName/*_Chunk*/*.root
    rm -f taskfiles.log
    python $fileChecker --log taskfiles.log $_sourceFiles
    # if the file with the corrupted files list is empty
    if ! [ -s taskfiles.log ]; then
	cd $_remotePath/$_taskName && echo $PWD
	haddChunks.py -n . || return 1
	mv $_taskName.root ../trees/.
	cd -
    else
	echo "Task $_taskName failed to hadd" | tee $logFile	
    fi
    return 0
}

##############################################################################################

## configure which hadd func to be used
[ "$haddMode" == "normal" ] && haddCmd=checkAndHadd
[ "$haddMode" == "nano" ] && haddCmd=checkAndHaddNanos
[ -z "$haddCmd" ] && { echo "Unknown haddMode '$haddMode'"; exit 1; }
echo "haddMode is set to $haddMode, $haddCmd func will be used" | tee $logFile

## info fetched for all the jobs
logFiles=$(ls $input/*Chunk*/*log | wc | awk '{print $1}')
(( $logFiles == 0 )) && { echo "Zero (0) log files in $taskDir."; exit 1; }

## info fetched for each sample(task) seperately
taskNames=($(grep "Bulk submission" $input/nanopy.log | awk -F '[ (]' '{print $4}'))
taskChunks=($(grep "Bulk submission" $input/nanopy.log | awk -F '[ (]' '{print $6}'))
taskFilesInEOS=($(for value in ${taskNames[@]}; do printf "0 "; done)) # fill it with 0s
nTasks=${#taskNames[@]}

## remove from the arrays the tasks which are already finished (if filesInEos equal to #chunks and file exists in <output>/trees/)
for i in "${!taskNames[@]}"; do
    { (( ${taskFilesInEOS[$i]} == ${taskChunks[$i]} )) && [ -e $output/trees/${taskNames[$i]}.root ]; } && {
	    unset taskNames[$i]
	    unset taskChunks[$i]
	    unset taskFilesInEOS[$i]
    }
done

## the main loop functionality
while true; do

    #### checkIfJobsFinished $dogfreq ## DEPRICATED

    ## getting info about fs quota and finished jobs
    quota=$(fs quota | awk '{print $1}' | sed s/%//); echo "Current afs-quota ${quota}% (action to be taken after ${quotaThreshold}%)"
    finishedJobs=$(grep -o "return value 0" $input/*Chunk*/*log | wc | awk '{print $1}')

    ## if quota threshold exceeded -> run
    (( $quota > $quotaThreshold )) && {
	# move finished to EOS
	moveFinishedToEOS $input $output
	# update taskFilesInEOS array
	for i in "${!taskNames[@]}"; do
	    # if directories of the task exist in the output-dir
	    ls $output/${taskNames[$i]}/*/ -d &>/dev/null && \
		taskFilesInEOS[$i]=$(ls $output/${taskNames[$i]} | wc | awk '{print $1}')
	done
	# run checkAndHadd for the finished tasks and update the taskFilesInEOS array again
	for i in "${!taskNames[@]}"; do
	    (( ${taskFilesInEOS[$i]} == ${taskChunks[$i]} )) && {
		$haddCmd $output ${taskNames[$i]} && {
		    unset taskNames[$i]
		    unset taskChunks[$i]
		    unset taskFilesInEOS[$i]
		}
	    }
	done
    }

    ## if finished move the last local files to EOS and break the loop
    { (( $finishedJobs == $logFiles )) || (( ${#taskNames[@]} == 0 )); } && {
	moveFinishedToEOS $input $output
	break
    }

    ## print info and sleep
    echo "Tasks running still:"
    echo ${taskNames[@]} | tr ' ' ', ' | sed "s/^,/( /; s/,$/ )/"
    echo "Moved files for each:"
    echo ${taskFilesInEOS[@]} | tr ' ' ', ' | sed "s/^,/( /; s/,$/ )/"
    echo "Will sleep for $dogfreq | $(date)"
    sleep $dogfreq
done

## check if the remote files are equal to the jobs ran
rootChunkFiles=$(ls $output/*/*_Chunks*/*root | grep -v "trees/[^/]*\.root$" | wc | awk '{print $1}')
(( $rootChunkFiles != $logFiles )) && { echo "All jobs have finished but the remote FILES are less than the JOBS ran."; exit 1; }

## check if the remote final files are equal to the tasks ran
rootFinalFiles=$(ls $output/trees/*root | wc | awk '{print $1}')
(( $rootFinalFiles != $nTasks )) && { echo "All jobs have finished but the remote FINAL FILES are less than the TASKS ran."; exit 1; }

exit 0
